#Common testing modules
from common import testing_resource_path

#Feynman modules
from feynman import parsing, integration

#System modules
from os.path import join

def test_integrator_generation():
    #Grab the input code path
    input_code_path = join(testing_resource_path, "parsing_test_code.cl")

    #Parse the input code
    input_code = parsing.CFile(input_code_path)
    
    #Make sure there is at least one function detected
    assert(len(input_code.function_declarations) > 0)

    #Loop through and generate an integrator for each integrand,
    #validating that the integrators make sense.
    for integrand in input_code.function_declarations:
        #Create an integrator
        integrator = integration.FunctionIntegrator(integrand)

        #Make sure the return types match
        assert(integrator.evaluation_function.return_type == integrand.return_type)

        #Make sure there is no body detected, since that
        #will be generated by an integrator when generating
        #code.
        assert(not integrator.evaluation_function.has_body)

        #Make sure the argumet types make sense.  There should
        #be twice as many argument_types for the integrator as the
        #integrand (for lower and upper limits), and the types
        #should match up.
        assert(len(integrand.argument_types) > 0)
        assert(len(integrator.evaluation_function.argument_types) == ((2 * len(integrand.argument_types)) + 1))
        assert(integrator.n_dimensions == len(integrand.argument_types))
        arg_i = 0
        for arg_type in integrand.argument_types:
            for i in xrange(0, 2):
                assert(integrator.evaluation_function.argument_types[arg_i + i])
            arg_i += 2

        #Make sure the argument names make sense.
        assert(len(integrand.argument_names) == len(integrand.argument_types))
